{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auto-resize-textarea",
  "type": "registry:component",
  "title": "Auto Resize TextArea",
  "description": "A textarea component that automatically adjusts its height based on content",
  "files": [
    {
      "path": "src/registry/new-york/auto-resize-textarea/auto-resize-textarea.tsx",
      "content": "import React, { useCallback, useEffect, useRef, useState } from \"react\";\n\nconst MAX_TEXTAREA_HEIGHT = 100;\nconst MIN_TEXTAREA_HEIGHT = 32;\n\ninterface AutoResizeTextareaProps {\n  value: string;\n  onChange: (value: string) => void;\n  onSubmit?: () => void;\n  disabled?: boolean;\n  placeholder?: string;\n}\n\nexport const AutoResizeTextarea: React.FC<AutoResizeTextareaProps> = ({\n  value,\n  onChange,\n  disabled = false,\n  placeholder = \"Enter a message...\",\n}) => {\n  const textAreaRef = useRef<HTMLTextAreaElement>(null);\n  const [isComposing, setIsComposing] = useState(false);\n  const [localValue, setLocalValue] = useState(value);\n  const measurementsCacheRef = useRef<{\n    width?: number;\n    height?: number;\n    scrollHeight?: number;\n  }>({});\n\n  useEffect(() => {\n    if (textAreaRef.current) {\n      textAreaRef.current.focus();\n    }\n  }, []);\n\n  // Synchronize external value changes (ignore during IME input)\n  useEffect(() => {\n    if (!isComposing && value !== localValue) {\n      setLocalValue(value);\n    }\n  }, [value, isComposing, localValue]);\n\n  const adjustHeight = useCallback((element: HTMLTextAreaElement) => {\n    // Performance optimization: reuse previous calculation if width is the same\n    const currentWidth = element.offsetWidth;\n    if (\n      measurementsCacheRef.current.width === currentWidth &&\n      measurementsCacheRef.current.scrollHeight === element.scrollHeight\n    ) {\n      return;\n    }\n\n    // Reset height to get accurate scrollHeight\n    element.style.height = \"auto\";\n    const newHeight = Math.min(element.scrollHeight, MAX_TEXTAREA_HEIGHT);\n    element.style.height = `${newHeight}px`;\n\n    // Update cache\n    measurementsCacheRef.current = {\n      width: currentWidth,\n      height: newHeight,\n      scrollHeight: element.scrollHeight,\n    };\n  }, []);\n\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const newValue = e.target.value;\n    setLocalValue(newValue);\n\n    // Notify parent immediately if not composing with IME\n    if (!isComposing) {\n      onChange(newValue);\n    }\n\n    adjustHeight(e.target);\n  };\n\n  const handleCompositionStart = () => {\n    setIsComposing(true);\n  };\n\n  const handleCompositionEnd = (\n    e: React.CompositionEvent<HTMLTextAreaElement>,\n  ) => {\n    setIsComposing(false);\n    // Notify parent immediately when IME composition is confirmed\n    const finalValue = e.currentTarget.value;\n    onChange(finalValue);\n    setLocalValue(finalValue);\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    // Skip Enter key processing during IME input\n    if (isComposing) {\n      return;\n    }\n\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      const textarea = e.currentTarget;\n      const start = textarea.selectionStart;\n      const end = textarea.selectionEnd;\n      const newValue =\n        localValue.substring(0, start) + \"\\n\" + localValue.substring(end);\n\n      setLocalValue(newValue);\n      // Notify parent immediately for Enter key line breaks\n      onChange(newValue);\n\n      // Set cursor position\n      requestAnimationFrame(() => {\n        if (textAreaRef.current) {\n          textAreaRef.current.selectionStart =\n            textAreaRef.current.selectionEnd = start + 1;\n          adjustHeight(textAreaRef.current);\n        }\n      });\n    }\n  };\n\n  // Handle paste operations\n  const handlePaste = () => {\n    // Notify parent immediately on paste\n    setTimeout(() => {\n      if (textAreaRef.current && !isComposing) {\n        const newValue = textAreaRef.current.value;\n        setLocalValue(newValue);\n        onChange(newValue);\n        adjustHeight(textAreaRef.current);\n      }\n    }, 0);\n  };\n\n  // Handle window resize\n  useEffect(() => {\n    const handleResize = () => {\n      if (textAreaRef.current) {\n        // Clear cache and force recalculation\n        measurementsCacheRef.current = {};\n        adjustHeight(textAreaRef.current);\n      }\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [adjustHeight]);\n\n  // Adjust height on initial load and value changes\n  useEffect(() => {\n    if (textAreaRef.current) {\n      adjustHeight(textAreaRef.current);\n    }\n  }, [localValue, adjustHeight]);\n\n  return (\n    <textarea\n      ref={textAreaRef}\n      value={localValue}\n      onChange={handleChange}\n      onCompositionStart={handleCompositionStart}\n      onCompositionEnd={handleCompositionEnd}\n      onKeyDown={handleKeyDown}\n      onPaste={handlePaste}\n      rows={1}\n      className=\"w-full bg-transparent text-foreground resize-none outline-none text-sm scrollbar-hide\"\n      style={{\n        minHeight: `${MIN_TEXTAREA_HEIGHT}px`,\n        maxHeight: `${MAX_TEXTAREA_HEIGHT}px`,\n      }}\n      placeholder={placeholder}\n      readOnly={disabled}\n    />\n  );\n};\n",
      "type": "registry:component",
      "target": "components/ui/auto-resize-textarea.tsx"
    }
  ]
}
