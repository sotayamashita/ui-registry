{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "chat",
  "type": "registry:block",
  "title": "AI Chat System",
  "description": "AI assistant chat interface with streaming, tool calling, and Markdown support",
  "dependencies": ["lucide-react", "react-markdown", "remark-gfm"],
  "registryDependencies": [
    "button",
    "switch",
    "scroll-area",
    "accordion",
    "badge",
    "card",
    "separator",
    "tooltip",
    "auto-resize-textarea"
  ],
  "files": [
    {
      "path": "src/registry/new-york/blocks/chat/page.tsx",
      "content": "\"use client\";\n\nimport { Chat } from \"./components/chat\";\nimport { useChat } from \"./hooks/use-chat\";\nimport { mockApiCall } from \"./lib/mock\";\n\nexport const ChatExamplePage = () => {\n  const {\n    messages,\n    input,\n    isLoading,\n    streamMode,\n    handleInputChange,\n    handleSubmit,\n    append,\n    reset,\n    toggleStreamMode,\n    stop,\n    abortControllerRef,\n    setMessages,\n  } = useChat({\n    onSendMessage: async (content: string) => {\n      // Add user message\n      append({\n        role: \"user\",\n        content,\n      });\n\n      // Add assistant message placeholder\n      const assistantMessage = append({\n        role: \"assistant\",\n        content: \"Processing your request... (this will take 3 seconds)\",\n      });\n\n      try {\n        // Use the abortController's signal for the mock API call\n        const response = await mockApiCall(\n          content,\n          abortControllerRef.current?.signal,\n        );\n\n        // Update assistant message with response\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === assistantMessage.id\n              ? { ...msg, content: response }\n              : msg,\n          ),\n        );\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message === \"Request was cancelled by user\"\n        ) {\n          // Message is already marked as cancelled by the stop() function\n          setMessages((prev) =>\n            prev.map((msg) =>\n              msg.id === assistantMessage.id\n                ? { ...msg, content: \"Request was cancelled\" }\n                : msg,\n            ),\n          );\n        } else {\n          setMessages((prev) =>\n            prev.map((msg) =>\n              msg.id === assistantMessage.id\n                ? {\n                    ...msg,\n                    content: `Error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n                  }\n                : msg,\n            ),\n          );\n        }\n      }\n    },\n    onError: (error) => {\n      console.error(\"Chat error:\", error);\n    },\n  });\n\n  return (\n    <div className=\"h-screen flex flex-col\">\n      <div className=\"flex-1 overflow-hidden\">\n        <Chat\n          messages={messages}\n          onSendMessage={handleSubmit}\n          onReset={reset}\n          onCancel={stop}\n          isLoading={isLoading}\n          placeholder=\"Type a message... (Will take 3 seconds to respond)\"\n          value={input}\n          onChange={handleInputChange}\n          streamMode={streamMode}\n          onStreamModeChange={toggleStreamMode}\n        />\n      </div>\n    </div>\n  );\n};\n",
      "type": "registry:page",
      "target": "app/chat/page.tsx"
    },
    {
      "path": "src/registry/new-york/blocks/chat/components/chat.tsx",
      "content": "\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Switch } from \"@/components/ui/switch\";\nimport React from \"react\";\nimport \"../styles/scrollbar.css\";\nimport { ChatProps } from \"../types/chat-types\";\nimport { ChatInput } from \"./chat-input\";\nimport { Message } from \"./message\";\n\nexport const Chat: React.FC<ChatProps> = ({\n  messages,\n  onSendMessage,\n  onReset,\n  onCancel,\n  isLoading = false,\n  isCancelling = false,\n  placeholder = \"Enter a message...\",\n  value,\n  onChange,\n  streamMode = false,\n  onStreamModeChange,\n  useLLM = false,\n  onUseLLMChange,\n  onThumbsUp,\n  onThumbsDown,\n}) => {\n  const [localInput, setLocalInput] = React.useState(\"\");\n  const input = value !== undefined ? value : localInput;\n  const setInput = onChange || setLocalInput;\n  const scrollEndRef = React.useRef<HTMLDivElement>(null);\n  const [scrollbarWidth, setScrollbarWidth] = React.useState(0);\n\n  React.useEffect(() => {\n    // Measure scrollbar width\n    const scrollDiv = document.createElement(\"div\");\n    scrollDiv.style.width = \"100px\";\n    scrollDiv.style.height = \"100px\";\n    scrollDiv.style.overflow = \"scroll\";\n    scrollDiv.style.position = \"absolute\";\n    scrollDiv.style.top = \"-9999px\";\n    document.body.appendChild(scrollDiv);\n    const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    setScrollbarWidth(scrollbarWidth);\n  }, []);\n\n  React.useEffect(() => {\n    scrollEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [messages]);\n\n  const handleSubmit = () => {\n    if (input.trim()) {\n      onSendMessage(input);\n      setInput(\"\");\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      <div className=\"flex items-center justify-between px-4 py-2 border-b\">\n        <div className=\"flex items-center gap-4\">\n          <div className=\"flex items-center gap-2\">\n            <label htmlFor=\"stream-mode\" className=\"text-sm font-medium\">\n              Stream Mode\n            </label>\n            <Switch\n              id=\"stream-mode\"\n              checked={streamMode}\n              onCheckedChange={onStreamModeChange}\n            />\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <label htmlFor=\"use-llm\" className=\"text-sm font-medium\">\n              Use Real LLM\n            </label>\n            <Switch\n              id=\"use-llm\"\n              checked={useLLM}\n              onCheckedChange={onUseLLMChange}\n            />\n          </div>\n        </div>\n        <Button onClick={onReset} variant=\"outline\" size=\"sm\">\n          Reset\n        </Button>\n      </div>\n      <div\n        className=\"flex-1 min-h-0 overflow-y-auto scrollbar-gutter-stable\"\n        style={{ paddingLeft: `${scrollbarWidth}px` }}\n      >\n        <div className=\"px-4 py-4\">\n          {messages.map((message) => (\n            <Message\n              key={message.id}\n              message={message}\n              streamMode={streamMode}\n              onThumbsUp={onThumbsUp}\n              onThumbsDown={onThumbsDown}\n            />\n          ))}\n          <div ref={scrollEndRef} />\n        </div>\n      </div>\n      <div\n        className=\"flex-shrink-0 bg-background border-t py-4\"\n        style={{\n          paddingLeft: `${scrollbarWidth + 16}px`,\n          paddingRight: `${scrollbarWidth + 16}px`,\n        }}\n      >\n        <ChatInput\n          value={input}\n          onChange={setInput}\n          onSubmit={handleSubmit}\n          onCancel={onCancel}\n          disabled={isLoading}\n          isLoading={isLoading}\n          isCancelling={isCancelling}\n          placeholder={placeholder}\n        />\n      </div>\n    </div>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/blocks/chat/components/message.tsx",
      "content": "import {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"@/components/ui/accordion\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\nimport { CopyButton } from \"@/registry/new-york/copy-button/copy-button\";\nimport {\n  AlertCircle,\n  ArrowLeft,\n  ArrowRight,\n  Hammer,\n  Loader2,\n  Origami,\n  ThumbsDown,\n  ThumbsUp,\n  User,\n} from \"lucide-react\";\nimport React from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport { Message as MessageType } from \"../types/chat-types\";\nimport { StreamMessage } from \"./stream-message\";\n\ninterface MessageProps {\n  message: MessageType;\n  streamMode?: boolean;\n  onThumbsUp?: (messageId: string) => void;\n  onThumbsDown?: (messageId: string) => void;\n}\n\nexport const Message: React.FC<MessageProps> = ({\n  message,\n  streamMode = false,\n  onThumbsUp,\n  onThumbsDown,\n}) => {\n  const getIcon = () => {\n    const size = \"size-4\";\n    switch (message.role) {\n      case \"user\":\n        return <User className={size} />;\n      case \"assistant\":\n        return <Origami className={size} />;\n      case \"tool\":\n        return <Hammer className={size} />;\n    }\n  };\n\n  const baseClasses = \"py-2 px-4 flex items-center my-4\";\n  const roleClasses =\n    message.role === \"user\"\n      ? \"rounded bg-gray-100 dark:bg-gray-800\"\n      : message.role === \"tool\"\n        ? \"border rounded\"\n        : \"\";\n\n  return (\n    <div\n      className={`${baseClasses} ${roleClasses} ${message.isCancelled ? \"opacity-60\" : \"\"}`}\n    >\n      <div className=\"flex items-start gap-3 w-full\">\n        <div className=\"rounded-full bg-gray-200 size-7 flex shrink-0 items-center justify-center\">\n          {getIcon()}\n        </div>\n        <div className=\"flex-1 min-w-0 translate-y-0.5\">\n          {message.isCancelled && (\n            <div className=\"flex items-center gap-2 mb-2 text-destructive\">\n              <AlertCircle className=\"size-4\" />\n              <span className=\"text-sm font-medium\">Request cancelled</span>\n            </div>\n          )}\n          {message.role === \"tool\" && message.toolInvocations ? (\n            <Accordion type=\"single\" collapsible defaultValue=\"item-1\">\n              <AccordionItem value=\"item-1\">\n                <AccordionTrigger className=\"p-0 hover:no-underline\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"font-medium\">\n                      {message.toolInvocations[0]?.toolName || \"Tool Call\"}\n                    </span>\n                    {message.toolInvocations[0]?.state === \"call\" &&\n                      !message.toolInvocations[0]?.result && (\n                        <Badge variant=\"secondary\" className=\"text-xs\">\n                          <Loader2 className=\"size-3 mr-1 animate-spin\" />\n                          Running\n                        </Badge>\n                      )}\n                    {message.toolInvocations[0]?.result && (\n                      <Badge variant=\"default\" className=\"text-xs\">\n                        Complete\n                      </Badge>\n                    )}\n                  </div>\n                </AccordionTrigger>\n                <AccordionContent className=\"pt-4 pb-0\">\n                  <div className=\"space-y-3\">\n                    {/* Input Section */}\n                    <Card className=\"border-blue-200 dark:border-blue-800 shadow-none\">\n                      <CardContent className=\"p-3\">\n                        <div className=\"flex items-center gap-2 mb-2\">\n                          <Badge\n                            variant=\"outline\"\n                            className=\"text-blue-600 dark:text-blue-400\"\n                          >\n                            <ArrowRight className=\"size-3 mr-1\" />\n                            INPUT\n                          </Badge>\n                          <span className=\"text-xs text-muted-foreground\">\n                            Arguments sent to{\" \"}\n                            {message.toolInvocations[0]?.toolName}\n                          </span>\n                        </div>\n                        <pre className=\"p-2 rounded bg-gray-50 dark:bg-gray-900 text-xs overflow-x-auto\">\n                          {JSON.stringify(\n                            message.toolInvocations[0]?.args || {},\n                            null,\n                            2,\n                          )}\n                        </pre>\n                      </CardContent>\n                    </Card>\n\n                    {/* Output Section */}\n                    {message.toolInvocations[0]?.result && (\n                      <>\n                        <div className=\"flex items-center justify-center\">\n                          <Separator className=\"flex-1\" />\n                          <span className=\"px-2 text-xs text-muted-foreground\">\n                            then\n                          </span>\n                          <Separator className=\"flex-1\" />\n                        </div>\n\n                        <Card className=\"border-green-200 dark:border-green-800 shadow-none\">\n                          <CardContent className=\"p-3\">\n                            <div className=\"flex items-center gap-2 mb-2\">\n                              <Badge\n                                variant=\"outline\"\n                                className=\"text-green-600 dark:text-green-400\"\n                              >\n                                <ArrowLeft className=\"size-3 mr-1\" />\n                                OUTPUT\n                              </Badge>\n                              <span className=\"text-xs text-muted-foreground\">\n                                Result from{\" \"}\n                                {message.toolInvocations[0]?.toolName}\n                              </span>\n                            </div>\n                            <pre className=\"p-2 rounded bg-gray-50 dark:bg-gray-900 text-xs overflow-x-auto\">\n                              {JSON.stringify(\n                                message.toolInvocations[0]?.result,\n                                null,\n                                2,\n                              )}\n                            </pre>\n                          </CardContent>\n                        </Card>\n                      </>\n                    )}\n                  </div>\n                </AccordionContent>\n              </AccordionItem>\n            </Accordion>\n          ) : message.role === \"assistant\" ? (\n            <div className=\"w-full\">\n              <StreamMessage\n                content={message.content}\n                isStreaming={message.isStreaming}\n              />\n              {!message.isStreaming && message.content && (\n                <div className=\"flex items-center gap-2 mt-2\">\n                  <TooltipProvider delayDuration={0}>\n                    <CopyButton\n                      value={message.content}\n                      variant=\"ghost\"\n                      className=\"p-1.5 size-auto hover:bg-gray-100 dark:hover:bg-gray-800 relative bg-transparent\"\n                    />\n                  </TooltipProvider>\n                  {(onThumbsUp || onThumbsDown) && (\n                    <>\n                      {onThumbsUp && (\n                        <button\n                          onClick={() => onThumbsUp(message.id)}\n                          className=\"p-1.5 rounded hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors\"\n                          title=\"Thumbs up\"\n                        >\n                          <ThumbsUp className=\"size-4 text-gray-500 hover:text-gray-700\" />\n                        </button>\n                      )}\n                      {onThumbsDown && (\n                        <button\n                          onClick={() => onThumbsDown(message.id)}\n                          className=\"p-1.5 rounded hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors\"\n                          title=\"Thumbs down\"\n                        >\n                          <ThumbsDown className=\"size-4 text-gray-500 hover:text-gray-700\" />\n                        </button>\n                      )}\n                    </>\n                  )}\n                </div>\n              )}\n            </div>\n          ) : (\n            <div className=\"prose prose-sm dark:prose-invert max-w-none\">\n              <ReactMarkdown\n                remarkPlugins={[remarkGfm]}\n                components={{\n                  p: ({ children }) => <p className=\"mb-0\">{children}</p>,\n                  code: ({ children, ...props }) => {\n                    const isInline = !(\n                      \"children\" in props &&\n                      props.children &&\n                      typeof props.children === \"object\" &&\n                      \"props\" in props.children\n                    );\n                    if (isInline) {\n                      return (\n                        <code className=\"bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded text-sm\">\n                          {children}\n                        </code>\n                      );\n                    }\n                    return (\n                      <code className=\"block bg-gray-100 dark:bg-gray-800 p-2 rounded my-2 overflow-x-auto text-sm\">\n                        {children}\n                      </code>\n                    );\n                  },\n                  pre: ({ children }) => (\n                    <pre className=\"bg-gray-100 dark:bg-gray-800 p-3 rounded my-2 overflow-x-auto\">\n                      {children}\n                    </pre>\n                  ),\n                }}\n              >\n                {message.content}\n              </ReactMarkdown>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/blocks/chat/components/chat-input.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\nimport { AutoResizeTextarea } from \"@/registry/new-york/auto-resize-textarea/auto-resize-textarea\";\nimport { ArrowUp, Loader2, X } from \"lucide-react\";\nimport React from \"react\";\n\ninterface ChatInputProps {\n  value: string;\n  onChange: (value: string) => void;\n  onSubmit: () => void;\n  onCancel?: () => void;\n  disabled?: boolean;\n  placeholder?: string;\n  isLoading?: boolean;\n  isCancelling?: boolean;\n}\n\nexport const ChatInput: React.FC<ChatInputProps> = ({\n  value,\n  onChange,\n  onSubmit,\n  onCancel,\n  disabled = false,\n  placeholder,\n  isLoading = false,\n  isCancelling = false,\n}) => {\n  const handleSubmit = (e?: React.FormEvent) => {\n    e?.preventDefault();\n    if (value.trim() && !disabled && !isLoading) {\n      onSubmit();\n    }\n  };\n\n  const handleCancel = (e: React.MouseEvent) => {\n    console.log(\"[ChatInput] handleCancel called\");\n    e.preventDefault();\n    e.stopPropagation();\n    console.log(\"[ChatInput] onCancel:\", onCancel);\n    console.log(\"[ChatInput] isCancelling:\", isCancelling);\n    if (onCancel && !isCancelling) {\n      console.log(\"[ChatInput] Calling onCancel function\");\n      onCancel();\n    } else {\n      console.log(\n        \"[ChatInput] onCancel not called - onCancel is\",\n        onCancel,\n        \"or isCancelling is\",\n        isCancelling,\n      );\n    }\n  };\n\n  const getButtonIcon = () => {\n    if (isCancelling) {\n      return <Loader2 className=\"animate-spin\" />;\n    }\n    if (isLoading) {\n      return <X />;\n    }\n    return <ArrowUp />;\n  };\n\n  const getButtonClassName = () => {\n    let baseClass = \"ml-auto size-7 rounded-full transition-colors\";\n    if (isCancelling) {\n      baseClass += \" bg-destructive hover:bg-destructive/90\";\n    }\n    return baseClass;\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"py-4 border rounded-lg shadow-md\">\n      <AutoResizeTextarea\n        value={value}\n        onChange={onChange}\n        onSubmit={handleSubmit}\n        disabled={disabled || isLoading || isCancelling}\n        placeholder={placeholder}\n      />\n      <div className=\"flex items-center px-4\">\n        <Button\n          type={isLoading ? \"button\" : \"submit\"}\n          size=\"icon\"\n          className={getButtonClassName()}\n          disabled={(!isLoading && !value.trim()) || isCancelling}\n          onClick={(e) => {\n            if (isLoading) {\n              handleCancel(e);\n            }\n          }}\n        >\n          {getButtonIcon()}\n        </Button>\n      </div>\n    </form>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/blocks/chat/components/stream-message.tsx",
      "content": "import { Loader2 } from \"lucide-react\";\nimport React from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\n\ninterface StreamMessageProps {\n  content: string;\n  isStreaming?: boolean;\n}\n\nexport const StreamMessage: React.FC<StreamMessageProps> = ({\n  content,\n  isStreaming = false,\n}) => {\n  return (\n    <div className=\"relative overflow-hidden\">\n      <div className=\"prose prose-sm dark:prose-invert max-w-none\">\n        <ReactMarkdown\n          remarkPlugins={[remarkGfm]}\n          components={{\n            h1: ({ children }) => (\n              <h1 className=\"text-2xl font-bold mt-4 mb-2\">{children}</h1>\n            ),\n            h2: ({ children }) => (\n              <h2 className=\"text-xl font-bold mt-4 mb-2\">{children}</h2>\n            ),\n            h3: ({ children }) => (\n              <h3 className=\"text-lg font-semibold mt-4 mb-2\">{children}</h3>\n            ),\n            p: ({ children }) => <p className=\"mb-2\">{children}</p>,\n            ul: ({ children }) => (\n              <ul className=\"list-disc pl-6 mb-2\">{children}</ul>\n            ),\n            ol: ({ children }) => (\n              <ol className=\"list-decimal pl-6 mb-2\">{children}</ol>\n            ),\n            li: ({ children }) => <li className=\"mb-1\">{children}</li>,\n            blockquote: ({ children }) => (\n              <blockquote className=\"border-l-4 border-gray-300 dark:border-gray-600 pl-4 my-2 italic\">\n                {children}\n              </blockquote>\n            ),\n            code: ({ children, ...props }) => {\n              const isInline = !(\n                \"children\" in props &&\n                props.children &&\n                typeof props.children === \"object\" &&\n                \"props\" in props.children\n              );\n              if (isInline) {\n                return (\n                  <code className=\"bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded text-sm\">\n                    {children}\n                  </code>\n                );\n              }\n              return (\n                <code className=\"block bg-gray-100 dark:bg-gray-800 p-2 rounded my-2 overflow-x-auto text-sm\">\n                  {children}\n                </code>\n              );\n            },\n            pre: ({ children }) => (\n              <pre className=\"bg-gray-100 dark:bg-gray-800 p-3 rounded my-2 overflow-x-auto\">\n                {children}\n              </pre>\n            ),\n            table: ({ children }) => (\n              <div className=\"overflow-x-auto my-2\">\n                <table className=\"min-w-full divide-y divide-gray-200 dark:divide-gray-700\">\n                  {children}\n                </table>\n              </div>\n            ),\n            th: ({ children }) => (\n              <th className=\"px-3 py-2 bg-gray-50 dark:bg-gray-800 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider\">\n                {children}\n              </th>\n            ),\n            td: ({ children }) => (\n              <td className=\"px-3 py-2 whitespace-nowrap text-sm text-gray-900 dark:text-gray-100\">\n                {children}\n              </td>\n            ),\n            a: ({ href, children }) => (\n              <a\n                href={href}\n                className=\"text-blue-600 dark:text-blue-400 hover:underline\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                {children}\n              </a>\n            ),\n          }}\n        >\n          {content}\n        </ReactMarkdown>\n      </div>\n      {isStreaming && (\n        <Loader2 className=\"inline-block size-3 ml-1 animate-spin text-muted-foreground\" />\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/blocks/chat/components/message-list.tsx",
      "content": "import { ScrollArea } from \"@/components/ui/scroll-area\";\nimport React, { useEffect, useRef } from \"react\";\nimport { Message as MessageType } from \"../types/chat-types\";\nimport { Message } from \"./message\";\n\ninterface MessageListProps {\n  messages: MessageType[];\n}\n\nexport const MessageList: React.FC<MessageListProps> = ({ messages }) => {\n  const scrollEndRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    scrollEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [messages]);\n\n  return (\n    <ScrollArea className=\"pr-4\">\n      {messages.map((message) => (\n        <Message key={message.id} message={message} />\n      ))}\n      <div ref={scrollEndRef} />\n    </ScrollArea>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/blocks/chat/hooks/use-chat.ts",
      "content": "\"use client\";\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { Message } from \"../types/chat-types\";\n\ntype ChatStatus = \"idle\" | \"loading\" | \"streaming\" | \"error\";\n\ninterface UseChatOptions {\n  initialMessages?: Message[];\n  onSendMessage?: (content: string) => void;\n  streamMode?: boolean;\n  onError?: (error: Error) => void;\n  keepLastMessageOnError?: boolean;\n  experimental_throttle?: number;\n}\n\ninterface UseChatHelpers {\n  messages: Message[];\n  input: string;\n  isLoading: boolean;\n  isCancelling: boolean;\n  streamMode: boolean;\n  status: ChatStatus;\n  error: Error | undefined;\n  handleInputChange: (value: string) => void;\n  handleSubmit: () => Promise<void>;\n  append: (message: Omit<Message, \"id\" | \"timestamp\">) => Message;\n  reset: () => void;\n  addMessage: (message: Omit<Message, \"id\" | \"timestamp\">) => Message;\n  addToolResult: (toolCallId: string, result: Record<string, unknown>) => void;\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n  toggleStreamMode: () => void;\n  appendStream: (messageId: string, chunk: string) => void;\n  finalizeStream: (messageId: string) => void;\n  stop: () => void;\n  reload: () => Promise<void>;\n  abortControllerRef: React.MutableRefObject<AbortController | null>;\n}\n\nexport const useChat = (options: UseChatOptions = {}): UseChatHelpers => {\n  const [messages, setMessages] = useState<Message[]>(\n    options.initialMessages || [],\n  );\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [isCancelling, setIsCancelling] = useState(false);\n  const [streamMode, setStreamMode] = useState(options.streamMode || false);\n  const [status, setStatus] = useState<ChatStatus>(\"idle\");\n  const [error, setError] = useState<Error | undefined>();\n\n  // Abort controller for cancelling ongoing requests\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Track the last user message for reload functionality\n  const lastUserMessageRef = useRef<string>(\"\");\n\n  // Throttling state\n  const throttleTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const pendingUpdatesRef = useRef<Array<() => void>>([]);\n\n  // Throttle function for UI updates\n  const throttleUpdate = useCallback(\n    (updateFn: () => void) => {\n      if (!options.experimental_throttle) {\n        updateFn();\n        return;\n      }\n\n      pendingUpdatesRef.current.push(updateFn);\n\n      if (!throttleTimerRef.current) {\n        throttleTimerRef.current = setTimeout(() => {\n          const updates = pendingUpdatesRef.current;\n          pendingUpdatesRef.current = [];\n          throttleTimerRef.current = null;\n\n          // Execute all pending updates\n          updates.forEach((fn) => fn());\n        }, options.experimental_throttle);\n      }\n    },\n    [options.experimental_throttle],\n  );\n\n  const append = useCallback((message: Omit<Message, \"id\" | \"timestamp\">) => {\n    const newMessage: Message = {\n      ...message,\n      id: `msg-${Date.now()}-${Math.random()}`,\n      timestamp: new Date(),\n    };\n    setMessages((prev) => [...prev, newMessage]);\n    return newMessage;\n  }, []);\n\n  const handleInputChange = useCallback((value: string) => {\n    setInput(value);\n  }, []);\n\n  const handleSubmit = useCallback(async () => {\n    if (!input.trim()) return;\n\n    const userMessage = input;\n    lastUserMessageRef.current = userMessage;\n    setInput(\"\");\n    setError(undefined);\n\n    // If onSendMessage is provided, let it handle adding the message\n    // Otherwise, add the message directly\n    if (options.onSendMessage) {\n      setIsLoading(true);\n      setStatus(\"loading\");\n\n      // Create new abort controller for this request\n      abortControllerRef.current = new AbortController();\n\n      try {\n        await options.onSendMessage(userMessage);\n        setStatus(\"idle\");\n      } catch (err) {\n        setStatus(\"error\");\n        const error =\n          err instanceof Error ? err : new Error(\"Unknown error occurred\");\n        setError(error);\n\n        if (options.onError) {\n          options.onError(error);\n        }\n\n        // Remove last message if keepLastMessageOnError is false\n        if (!options.keepLastMessageOnError && messages.length > 0) {\n          setMessages((prev) => prev.slice(0, -1));\n        }\n      } finally {\n        setIsLoading(false);\n        setIsCancelling(false);\n        abortControllerRef.current = null;\n      }\n    } else {\n      // Only add user message if no onSendMessage callback\n      append({\n        role: \"user\",\n        content: userMessage,\n      });\n    }\n  }, [input, append, options, messages.length]);\n\n  const reset = useCallback(() => {\n    setMessages([]);\n    setInput(\"\");\n    setIsLoading(false);\n    setStatus(\"idle\");\n    setError(undefined);\n    lastUserMessageRef.current = \"\";\n\n    // Cancel any ongoing requests\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const addMessage = useCallback(\n    (message: Omit<Message, \"id\" | \"timestamp\">) => {\n      return append(message);\n    },\n    [append],\n  );\n\n  const addToolResult = useCallback(\n    (toolCallId: string, result: Record<string, unknown>) => {\n      throttleUpdate(() => {\n        setMessages((prev) =>\n          prev.map((msg) => {\n            if (\n              msg.toolInvocations?.some((inv) => inv.toolCallId === toolCallId)\n            ) {\n              return {\n                ...msg,\n                toolInvocations: msg.toolInvocations.map((inv) =>\n                  inv.toolCallId === toolCallId\n                    ? { ...inv, state: \"result\" as const, result }\n                    : inv,\n                ),\n              };\n            }\n            return msg;\n          }),\n        );\n      });\n    },\n    [throttleUpdate],\n  );\n\n  const toggleStreamMode = useCallback(() => {\n    setStreamMode((prev) => !prev);\n  }, []);\n\n  const appendStream = useCallback(\n    (messageId: string, chunk: string) => {\n      throttleUpdate(() => {\n        setMessages((prev) =>\n          prev.map((msg) => {\n            if (msg.id === messageId) {\n              // Update status to streaming if not already\n              if (status !== \"streaming\") {\n                setStatus(\"streaming\");\n              }\n\n              return {\n                ...msg,\n                content: chunk, // Replace content instead of appending\n                isStreaming: true,\n              };\n            }\n            return msg;\n          }),\n        );\n      });\n    },\n    [throttleUpdate, status],\n  );\n\n  const finalizeStream = useCallback((messageId: string) => {\n    setMessages((prev) =>\n      prev.map((msg) => {\n        if (msg.id === messageId) {\n          return {\n            ...msg,\n            isStreaming: false,\n          };\n        }\n        return msg;\n      }),\n    );\n    setStatus(\"idle\");\n  }, []);\n\n  // Stop function to abort ongoing requests\n  const stop = useCallback(() => {\n    console.log(\"[useChat] stop function called\");\n    console.log(\n      \"[useChat] abortControllerRef.current:\",\n      abortControllerRef.current,\n    );\n    setIsCancelling(true);\n\n    if (abortControllerRef.current) {\n      console.log(\"[useChat] Aborting request\");\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n\n    // Mark the last assistant message as cancelled and finalize any streaming\n    setMessages((prev) => {\n      const lastAssistantIndex = prev.findLastIndex(\n        (msg) => msg.role === \"assistant\",\n      );\n      console.log(\n        \"[useChat] Last assistant message index:\",\n        lastAssistantIndex,\n      );\n      return prev.map((msg, index) => ({\n        ...msg,\n        isStreaming: false,\n        ...(index === lastAssistantIndex && msg.role === \"assistant\"\n          ? { isCancelled: true }\n          : {}),\n      }));\n    });\n\n    // Reset states after a short delay to show the cancelling state\n    setTimeout(() => {\n      setIsLoading(false);\n      setIsCancelling(false);\n      setStatus(\"idle\");\n    }, 100);\n  }, []);\n\n  // Reload function to retry the last AI response\n  const reload = useCallback(async () => {\n    if (!lastUserMessageRef.current || !options.onSendMessage) {\n      return;\n    }\n\n    // Find and remove the last assistant message\n    const lastAssistantIndex = messages.findLastIndex(\n      (msg) => msg.role === \"assistant\",\n    );\n    if (lastAssistantIndex !== -1) {\n      setMessages((prev) => prev.slice(0, lastAssistantIndex));\n    }\n\n    setError(undefined);\n    setIsLoading(true);\n    setStatus(\"loading\");\n\n    // Create new abort controller for this request\n    abortControllerRef.current = new AbortController();\n\n    try {\n      await options.onSendMessage(lastUserMessageRef.current);\n      setStatus(\"idle\");\n    } catch (err) {\n      setStatus(\"error\");\n      const error =\n        err instanceof Error ? err : new Error(\"Unknown error occurred\");\n      setError(error);\n\n      if (options.onError) {\n        options.onError(error);\n      }\n    } finally {\n      setIsLoading(false);\n      setIsCancelling(false);\n      abortControllerRef.current = null;\n    }\n  }, [messages, options]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      if (throttleTimerRef.current) {\n        clearTimeout(throttleTimerRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    messages,\n    input,\n    isLoading,\n    isCancelling,\n    streamMode,\n    status,\n    error,\n    handleInputChange,\n    handleSubmit,\n    append,\n    reset,\n    addMessage,\n    addToolResult,\n    setMessages,\n    toggleStreamMode,\n    appendStream,\n    finalizeStream,\n    stop,\n    reload,\n    abortControllerRef,\n  };\n};\n",
      "type": "registry:hook"
    },
    {
      "path": "src/registry/new-york/blocks/chat/lib/mock.ts",
      "content": "export const mockSleep = (ms: number, signal?: AbortSignal): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      resolve();\n    }, ms);\n\n    // Listen for abort signal\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        clearTimeout(timeout);\n        reject(new DOMException(\"Request was aborted\", \"AbortError\"));\n      });\n    }\n  });\n};\n\nexport const mockApiCall = async (\n  message: string,\n  signal?: AbortSignal,\n): Promise<string> => {\n  try {\n    // Simulate API delay (3 seconds)\n    await mockSleep(3000, signal);\n\n    // Simulate response\n    return `Mock response to: \"${message}\". This took 3 seconds to process.`;\n  } catch (error) {\n    if (error instanceof DOMException && error.name === \"AbortError\") {\n      throw new Error(\"Request was cancelled by user\");\n    }\n    throw error;\n  }\n};\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/new-york/blocks/chat/types/chat-types.ts",
      "content": "export interface ToolInvocation {\n  toolName: string;\n  toolCallId: string;\n  args?: Record<string, unknown>;\n  state: \"partial-call\" | \"call\" | \"result\";\n  result?: Record<string, unknown>;\n}\n\nexport interface Message {\n  id: string;\n  role: \"user\" | \"assistant\" | \"tool\";\n  content: string;\n  toolInvocations?: ToolInvocation[];\n  timestamp: Date;\n  isStreaming?: boolean;\n  isCancelled?: boolean;\n}\n\nexport interface ChatProps {\n  messages: Message[];\n  onSendMessage: (content: string) => void;\n  onReset: () => void;\n  onCancel?: () => void;\n  isLoading?: boolean;\n  isCancelling?: boolean;\n  placeholder?: string;\n  value?: string;\n  onChange?: (value: string) => void;\n  streamMode?: boolean;\n  onStreamModeChange?: (enabled: boolean) => void;\n  useLLM?: boolean;\n  onUseLLMChange?: (enabled: boolean) => void;\n  onThumbsUp?: (messageId: string) => void;\n  onThumbsDown?: (messageId: string) => void;\n}\n",
      "type": "registry:file",
      "target": "types/chat.ts"
    },
    {
      "path": "src/registry/new-york/blocks/chat/styles/scrollbar.css",
      "content": "/* Overlay scrollbar styles */\n.overlay-scrollbar {\n  /* For Webkit browsers */\n  overflow-y: overlay;\n  scrollbar-width: thin;\n}\n\n/* Custom scrollbar styling */\n.overlay-scrollbar::-webkit-scrollbar {\n  width: 12px;\n  background-color: transparent;\n}\n\n.overlay-scrollbar::-webkit-scrollbar-track {\n  background-color: transparent;\n}\n\n.overlay-scrollbar::-webkit-scrollbar-thumb {\n  background-color: rgba(0, 0, 0, 0.2);\n  border-radius: 6px;\n  border: 3px solid transparent;\n  background-clip: content-box;\n}\n\n.overlay-scrollbar::-webkit-scrollbar-thumb:hover {\n  background-color: rgba(0, 0, 0, 0.3);\n}\n\n/* Dark mode support */\n.dark .overlay-scrollbar::-webkit-scrollbar-thumb {\n  background-color: rgba(255, 255, 255, 0.2);\n}\n\n.dark .overlay-scrollbar::-webkit-scrollbar-thumb:hover {\n  background-color: rgba(255, 255, 255, 0.3);\n}\n\n/* Firefox */\n.overlay-scrollbar {\n  scrollbar-width: thin;\n  scrollbar-color: rgba(0, 0, 0, 0.2) transparent;\n}\n\n.dark .overlay-scrollbar {\n  scrollbar-color: rgba(255, 255, 255, 0.2) transparent;\n}\n\n/* Always reserve space for scrollbar */\n.scrollbar-gutter-stable {\n  scrollbar-gutter: stable;\n}\n\n/* Symmetric padding pattern */\n.symmetric-padding {\n  --scrollbar-width: 17px; /* Standard scrollbar width */\n}\n\n/* Reserve space on both sides */\n.scrollbar-gutter-stable.both {\n  scrollbar-gutter: stable both-edges;\n}\n\n/* Alternative approach with calculated padding */\n@supports (scrollbar-gutter: stable) {\n  .symmetric-scrollbar {\n    scrollbar-gutter: stable;\n    padding-left: var(--scrollbar-width);\n    margin-right: calc(-1 * var(--scrollbar-width));\n  }\n}\n",
      "type": "registry:file",
      "target": "styles/chat-scrollbar.css"
    }
  ],
  "categories": ["chat", "ai", "messaging", "blocks"]
}
